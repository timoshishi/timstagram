generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id         String     @id @default(cuid()) @db.Uuid
  username   String     @unique
  verifiedAt DateTime?  @map("email_verified")
  isVerified Boolean    @default(false)
  avatarUrl  String?
  createdAt  DateTime   @default(now()) @map(name: "created_at")
  updatedAt  DateTime   @updatedAt @map(name: "updated_at")
  banned     Boolean    @default(false)
  posts      Post[]    
  postFlags  PostFlag[]
  followers  Follows[]  @relation("following")
  following  Follows[]  @relation("follower")
  likes      PostLike[]
  comments   Comment[]
  isBot      Boolean    @default(false)

  @@index(username)
  @@map(name: "users")
}

// create a model for followers and following with their avatar url
model Follows {
  follower           User    @relation("follower", fields: [followerId], references: [id])
  followerId         String  @db.Uuid
  folowerAvatarUrl   String?
  followingId        String  @db.Uuid
  following          User    @relation("following", fields: [followingId], references: [id])
  followingAvatarUrl String?

  @@id([followerId, followingId])
}

model Post {
  id          String       @id // should be generated by server as nanoid
  title       String
  content     String?
  published   Boolean      @default(false)
  userId      String
  userName    String
  userAvatar  String
  userDeleted Boolean      @default(false)
  flagged     Boolean      @default(false)
  deleted     Boolean      @default(false)
  flagCount   Int          @default(0)
  postFlags   PostFlag[]
  viewCount   Int          @default(0)
  likes       Int          @default(0)
  mediaType   String?
  mediaUrl    String?       @unique
  mediaId     String
  createdAt   DateTime     @default(now())
  isBotPost   Boolean      @default(false)
  media       Media        @relation(fields: [mediaId], references: [id])
  user        User         @relation(fields: [userId], references: [id])
  postLikes   PostLike[]
  tags        TagOnPosts[]
  comments    Comment[]

  @@map("posts")
}
model Comment {
  id        String   @id @default(cuid()) @db.Uuid
  content   String
  userId    String   @db.Uuid
  user      User     @relation(fields: [userId], references: [id])
  postId    String
  post      Post?    @relation(fields: [postId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@map("comments")
}

model Media {
  id        String   @id // should be generated by server as nanoid
  url       String   @unique
  bucket    String
  type      String
  size      Int
  category  String
  deleted   Boolean @default(false)
  createdAt DateTime @default(now())
  posts     Post[]
  @@map("media")
}

enum FlagReason {
  ABUSIVE
  ILLEGAL
  COPYRIGHT
  OTHER
}

model PostFlag {
  postId    String
  userId    String  @db.Uuid
  reason    FlagReason
  content   String?
  createdAt DateTime   @default(now())
  post      Post       @relation(fields: [postId], references: [id])
  user      User       @relation(fields: [userId], references: [id])

  @@id([postId, userId])
  @@map("post_flags")
}



model PostLike {
  postId    String
  post      Post?    @relation(fields: [postId], references: [id], onDelete: Cascade)
  userId    String   @db.Uuid
  user      User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  doesLike  Boolean  @default(true)

  @@id([postId, userId])
  @@map("post_likes")
}

model TagOnPosts {
  id     String  @id @default(cuid())
  post   Post?   @relation(fields: [postId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  tag    Tag?    @relation(fields: [tagId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  postId String?
  tagId  String?

  @@map("post_tags")
}

model Tag {
  id    String       @id @default(cuid()) @db.Uuid
  name  String       @unique
  posts TagOnPosts[]

  @@map("tags")
}



// model VerificationToken {
//   identifier String
//   token      String   @unique
//   expires    DateTime

//   @@unique([identifier, token])
//   @@map("verification_tokens")
// }

// model Account {
//   id                 Int     @id @default(autoincrement())
//   userId             String  @map("user_id")
//   type               String
//   provider           String
//   providerAccountId  String  @map("provider_account_id")
//   refresh_token      String?
//   access_token       String?
//   expires_at         Int?
//   token_type         String?
//   scope              String?
//   id_token           String?
//   session_state      String?
//   oauth_token_secret String?
//   oauth_token        String?
//   // user User @relation(fields: [userId], references: [id], onDelete: Cascade)

//   @@unique([provider, providerAccountId])
//   @@map("accounts")
// }

// model Session {
//   id           Int      @id @default(autoincrement())
//   sessionToken String   @unique @map("session_token")
//   userId       String   @map("user_id")
//   expires      DateTime
// user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

//   @@map("sessions")
// }
